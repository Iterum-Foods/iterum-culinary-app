<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Ingredient Import - Iterum Culinary</title>
    
    <!-- Auth System -->
    <script src="assets/js/firebase-config.js"></script>
    <script src="assets/js/auth-manager.js"></script>
    <script src="assets/js/auth-api-helper.js"></script>
    <script src="assets/js/auth-diagnostics.js"></script>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/page-layouts.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .page-header {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 40px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(16, 185, 129, 0.3);
        }

        .page-header h1 {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 10px;
        }

        .page-header p {
            font-size: 1.125rem;
            opacity: 0.95;
        }

        .upload-section {
            background: white;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .upload-zone {
            border: 3px dashed #cbd5e1;
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8fafc;
        }

        .upload-zone:hover {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .upload-zone.dragover {
            border-color: #10b981;
            background: #d1fae5;
            transform: scale(1.02);
        }

        .btn {
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3);
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #1e293b;
        }

        .review-section {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            display: none;
        }

        .review-section.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid;
        }

        .stat-card.new {
            background: #d1fae5;
            border-color: #10b981;
        }

        .stat-card.duplicates {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .stat-card.total {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .stat-card.merge {
            background: #e9d5ff;
            border-color: #a855f7;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .filter-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 2px;
        }

        .filter-tab {
            padding: 10px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 600;
            color: #64748b;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }

        .filter-tab.active {
            color: #10b981;
            border-bottom-color: #10b981;
        }

        .ingredient-table {
            width: 100%;
            border-collapse: collapse;
        }

        .ingredient-table th {
            background: #f8fafc;
            padding: 12px 16px;
            text-align: left;
            font-weight: 700;
            color: #1e293b;
            border-bottom: 2px solid #e2e8f0;
            position: sticky;
            top: 0;
        }

        .ingredient-table td {
            padding: 16px;
            border-bottom: 1px solid #e2e8f0;
        }

        .ingredient-table tr:hover {
            background: #f8fafc;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .status-badge.new {
            background: #d1fae5;
            color: #10b981;
        }

        .status-badge.duplicate {
            background: #fef3c7;
            color: #f59e0b;
        }

        .action-select {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
        }

        .duplicate-info {
            font-size: 0.875rem;
            color: #64748b;
            margin-top: 4px;
        }

        .match-score {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 700;
            margin-left: 8px;
        }

        .match-high {
            background: #fee2e2;
            color: #991b1b;
        }

        .match-medium {
            background: #fef3c7;
            color: #92400e;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 30px;
            justify-content: flex-end;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f4f6;
            border-top: 4px solid #10b981;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    
    <!-- Unified Navigation & Project Selector -->
    <script src="assets/js/unified-nav-header.js" defer></script>
    <script src="assets/js/unified-project-selector.js" defer></script>
    <script src="assets/js/ingredient-url-scraper.js"></script>
    <link rel="stylesheet" href="assets/css/iterum-brand-kit.css">
    <link rel="stylesheet" href="assets/css/modal-high-contrast.css">
    <link rel="stylesheet" href="assets/css/header-universal.css">
    <link rel="stylesheet" href="assets/css/modern-nordic-vintage.css">
    <link rel="stylesheet" href="assets/css/dark-mode-enhancements.css">
    <script src="assets/js/import-service.js"></script>
</head>
<body style="padding-top: 80px;">
    <!-- Header -->
    <!-- Header injected by unified-nav-header.js -->

    <div class="container">
        <!-- Page Header -->
        <div class="page-header">
            <h1>üì• Bulk Ingredient Import</h1>
            <p>Upload CSV/Excel files to add multiple ingredients at once with smart duplicate detection</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-section">
            <h2 style="margin-bottom: 20px; color: #1e293b;">Upload Ingredient List</h2>
            
            <div class="upload-zone" id="uploadZone">
                <div style="font-size: 64px; margin-bottom: 20px;">üìä</div>
                <div style="font-size: 1.5rem; font-weight: 700; color: #1e293b; margin-bottom: 10px;">
                    Drag & Drop or Click to Upload
                </div>
                <div style="color: #64748b; margin-bottom: 20px;">
                    Supports CSV and Excel (.xlsx, .xls) files
                </div>
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                    <span>üìÅ</span>
                    <span>Choose File</span>
                </button>
                <button class="btn btn-secondary" style="margin-left: 8px;" onclick="window.importService?.openIngredientCSVImport()">
                    <span>üóÇÔ∏è</span>
                    <span>Import via Column Mapper</span>
                </button>
                <input type="file" id="fileInput" style="display: none;" accept=".csv,.xlsx,.xls" onchange="handleFileSelect(event)">
            </div>

            <div style="background: #f0f9ff; border-left: 4px solid #3b82f6; padding: 20px; border-radius: 8px; margin-top: 20px;">
                <h3 style="color: #1e40af; margin-bottom: 15px;">üìã Expected Format</h3>
                <ul style="list-style: none; padding: 0;">
                    <li style="padding: 8px 0; color: #1e40af;">‚úì Columns: Name, Category, Unit, Cost (optional), Supplier (optional)</li>
                    <li style="padding: 8px 0; color: #1e40af;">‚úì Example: "Chicken Breast, Protein, lb, 12.99, ACME Foods"</li>
                    <li style="padding: 8px 0; color: #1e40af;">‚úì Header row recommended</li>
                    <li style="padding: 8px 0; color: #1e40af;">‚úì Any order is fine - we'll detect columns</li>
                </ul>
                <button class="btn btn-secondary" onclick="downloadTemplate()" style="margin-top: 15px;">
                    <span>üì•</span>
                    <span>Download CSV Template</span>
                </button>
            </div>
        </div>

        <!-- Loading State -->
        <div class="loading" id="loadingState">
            <div class="spinner"></div>
            <p style="color: #64748b; font-weight: 600;">Processing ingredients and checking for duplicates...</p>
        </div>

        <!-- Review Section -->
        <div class="review-section" id="reviewSection">
            <h2 style="margin-bottom: 20px; color: #1e293b;">Review & Handle Duplicates</h2>
            
            <div class="stats-grid">
                <div class="stat-card new">
                    <div class="stat-number" id="newCount">0</div>
                    <div class="stat-label">New Ingredients</div>
                </div>
                <div class="stat-card duplicates">
                    <div class="stat-number" id="duplicateCount">0</div>
                    <div class="stat-label">Possible Duplicates</div>
                </div>
                <div class="stat-card merge">
                    <div class="stat-number" id="mergeCount">0</div>
                    <div class="stat-label">Will Merge</div>
                </div>
                <div class="stat-card total">
                    <div class="stat-number" id="totalCount">0</div>
                    <div class="stat-label">Total Uploaded</div>
                </div>
            </div>

            <div class="filter-tabs">
                <button class="filter-tab active" onclick="filterView('all')">All Items</button>
                <button class="filter-tab" onclick="filterView('new')">New Only</button>
                <button class="filter-tab" onclick="filterView('duplicates')">Duplicates Only</button>
            </div>

            <div style="overflow-x: auto;">
                <table class="ingredient-table">
                    <thead>
                        <tr>
                            <th>Ingredient Name</th>
                            <th>Category / Subcategory</th>
                            <th>Unit</th>
                            <th>Cost</th>
                            <th>Status</th>
                            <th>Duplicate Match</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="ingredientTableBody">
                        <!-- Rows populated by JS -->
                    </tbody>
                </table>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="cancelImport()">
                    <span>‚úï</span>
                    <span>Cancel</span>
                </button>
                <button class="btn btn-primary" onclick="saveIngredients()">
                    <span>‚úì</span>
                    <span>Save All</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let uploadedIngredients = [];
        let existingIngredients = [];
        let currentFilter = 'all';

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üì• Bulk Ingredient Import page loaded');
            loadExistingIngredients();
            setupDragAndDrop();
        });

        // Load existing ingredients
        function loadExistingIngredients() {
            const saved = localStorage.getItem('ingredients_database');
            if (saved) {
                existingIngredients = JSON.parse(saved);
                console.log('‚úÖ Loaded ' + existingIngredients.length + ' existing ingredients');
            } else {
                existingIngredients = [];
            }
        }

        // Drag and drop
        function setupDragAndDrop() {
            const zone = document.getElementById('uploadZone');
            
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('dragover');
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('dragover');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }

        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        // Process file
        function handleFile(file) {
            console.log('üìÑ Processing:', file.name);
            
            document.getElementById('loadingState').classList.add('active');
            document.querySelector('.upload-section').style.display = 'none';

            const extension = file.name.split('.').pop().toLowerCase();

            if (extension === 'csv' || extension === 'txt') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    setTimeout(() => parseCSV(e.target.result), 500);
                };
                reader.readAsText(file);
            } else if (extension === 'xlsx' || extension === 'xls') {
                parseExcel(file);
            } else {
                alert('Unsupported format. Please use CSV or Excel.');
                resetUpload();
            }
        }

        // Parse Excel
        function parseExcel(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    
                    // Parse to JSON with headers
                    const rawData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    
                    if (!rawData || rawData.length === 0) {
                        alert('Excel sheet appears to be empty');
                        resetUpload();
                        return;
                    }

                    // First row as headers
                    const headers = (rawData[0] || []).map(h => String(h || '').trim());
                    
                    // Store raw data
                    window.tempCSVData = {
                        headers: headers,
                        rawRows: []
                    };

                    // Convert rows to arrays and store
                    window.tempCSVAllRows = [];
                    for (let i = 1; i < rawData.length; i++) {
                        const row = (rawData[i] || []).map(cell => String(cell || '').trim());
                        if (row.length > 0 && row.some(c => c)) {
                            window.tempCSVAllRows.push(row);
                            if (window.tempCSVData.rawRows.length < 5) {
                                window.tempCSVData.rawRows.push(row);
                            }
                        }
                    }

                    console.log('‚úÖ Excel parsed');
                    document.getElementById('loadingState').classList.remove('active');
                    showColumnMapping();
                } catch (error) {
                    alert('Error parsing Excel: ' + error.message);
                    resetUpload();
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Parse CSV with column mapping
        function parseCSV(content) {
            // First, parse the CSV to detect headers
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length === 0) {
                alert('File appears to be empty');
                resetUpload();
                return;
            }

            // Detect delimiter
            const delimiter = detectDelimiter(content);
            
            // Parse first line as headers
            const headers = parseCSVLine(lines[0], delimiter);
            
            // Store raw data for mapping
            window.tempCSVData = {
                headers: headers,
                rawRows: []
            };

            // Parse sample rows for preview
            for (let i = 1; i < Math.min(lines.length, 6); i++) {
                const row = parseCSVLine(lines[i], delimiter);
                window.tempCSVData.rawRows.push(row);
            }

            // Store all rows
            window.tempCSVAllRows = [];
            for (let i = 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i], delimiter);
                window.tempCSVAllRows.push(row);
            }

            // Show column mapping UI
            showColumnMapping();
        }

        // Show column mapping interface
        function showColumnMapping() {
            const headers = window.tempCSVData.headers;
            const rawRows = window.tempCSVData.rawRows;

            // Hide loading, show mapping UI
            document.getElementById('loadingState').classList.remove('active');
            
            // Create mapping section if it doesn't exist
            let mappingSection = document.getElementById('columnMappingSection');
            if (!mappingSection) {
                mappingSection = document.createElement('div');
                mappingSection.id = 'columnMappingSection';
                mappingSection.className = 'upload-section';
                mappingSection.style.display = 'block';
                document.querySelector('.container').insertBefore(mappingSection, document.getElementById('reviewSection'));
            }

            // Define expected fields
            const expectedFields = [
                { key: 'name', label: 'Ingredient Name', required: true },
                { key: 'category', label: 'Category', required: false },
                { key: 'subcategory', label: 'Subcategory / Type / Brand', required: false },
                { key: 'unit', label: 'Unit', required: false },
                { key: 'cost', label: 'Cost', required: false },
                { key: 'supplier', label: 'Supplier', required: false }
            ];

            // Auto-detect mappings
            const mappings = {};
            expectedFields.forEach(field => {
                const match = findBestHeaderMatch(field.key, headers);
                mappings[field.key] = match || '';
            });

            // Store mappings globally
            window.columnMappings = mappings;

            // Build mapping UI
            mappingSection.innerHTML = `
                <h2 style="margin-bottom: 20px; color: #1e293b;">Map Columns</h2>
                <p style="color: #64748b; margin-bottom: 20px;">
                    Select which column from your file corresponds to each field below.
                </p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-bottom: 30px;">
                    ${expectedFields.map(field => {
                        const options = [
                            '<option value="">-- Not Mapped --</option>',
                            ...headers.map(header => 
                                `<option value="${header}" ${header === mappings[field.key] ? 'selected' : ''}>${header}</option>`
                            )
                        ].join('');
                        
                        return `
                            <label style="display: flex; flex-direction: column; gap: 8px;">
                                <span style="font-weight: 600; color: #1e293b;">
                                    ${field.label}${field.required ? ' *' : ''}
                                </span>
                                <select class="form-select" data-field="${field.key}" style="padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;" onchange="updateColumnMapping('${field.key}', this.value)">
                                    ${options}
                                </select>
                            </label>
                        `;
                    }).join('')}
                </div>

                <h3 style="margin-bottom: 12px; color: #1e293b;">Preview (First 5 Rows)</h3>
                <div style="overflow-x: auto; border: 1px solid #e2e8f0; border-radius: 12px; margin-bottom: 20px;">
                    <table class="ingredient-table">
                        <thead>
                            <tr>
                                ${headers.map(h => `<th>${h}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${rawRows.map(row => 
                                `<tr>${row.map(cell => `<td>${cell || ''}</td>`).join('')}</tr>`
                            ).join('')}
                        </tbody>
                    </table>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-secondary" onclick="cancelColumnMapping()">
                        <span>‚úï</span>
                        <span>Cancel</span>
                    </button>
                    <button class="btn btn-primary" onclick="confirmColumnMapping()">
                        <span>‚úì</span>
                        <span>Continue with Import</span>
                    </button>
                </div>
            `;
        }

        // Update column mapping
        function updateColumnMapping(fieldKey, headerValue) {
            if (!window.columnMappings) window.columnMappings = {};
            window.columnMappings[fieldKey] = headerValue;
        }

        // Cancel column mapping
        function cancelColumnMapping() {
            window.tempCSVData = null;
            window.tempCSVAllRows = null;
            window.columnMappings = null;
            const mappingSection = document.getElementById('columnMappingSection');
            if (mappingSection) mappingSection.remove();
            resetUpload();
        }

        // Confirm and process with mappings
        function confirmColumnMapping() {
            if (!window.columnMappings || !window.tempCSVAllRows || !window.tempCSVData) {
                alert('Please map at least the Ingredient Name column');
                return;
            }

            if (!window.columnMappings.name) {
                alert('Ingredient Name mapping is required');
                return;
            }

            // Hide mapping section
            const mappingSection = document.getElementById('columnMappingSection');
            if (mappingSection) mappingSection.style.display = 'none';

            // Process rows with mappings
            processMappedRows();
        }

        // Process rows using column mappings
        function processMappedRows() {
            document.getElementById('loadingState').classList.add('active');
            
            const mappings = window.columnMappings;
            const headers = window.tempCSVData.headers;
            const allRows = window.tempCSVAllRows;
            const data = [];

            // Create header index map
            const headerIndexMap = {};
            headers.forEach((header, index) => {
                headerIndexMap[header] = index;
            });

            // Process each row
            allRows.forEach((row, rowIndex) => {
                const ingredientName = (mappings.name && row[headerIndexMap[mappings.name]]) ? row[headerIndexMap[mappings.name]].trim() : '';
                const supplier = (mappings.supplier && row[headerIndexMap[mappings.supplier]]) ? row[headerIndexMap[mappings.supplier]].trim() : '';
                const cost = (mappings.cost && row[headerIndexMap[mappings.cost]]) ? parseFloat(row[headerIndexMap[mappings.cost]]) || null : null;
                
                const ingredient = {
                    name: ingredientName,
                    category: (mappings.category && row[headerIndexMap[mappings.category]]) ? row[headerIndexMap[mappings.category]].trim() : 'Uncategorized',
                    subcategory: (mappings.subcategory && row[headerIndexMap[mappings.subcategory]]) ? row[headerIndexMap[mappings.subcategory]].trim() : null,
                    unit: (mappings.unit && row[headerIndexMap[mappings.unit]]) ? row[headerIndexMap[mappings.unit]].trim() : 'ea',
                    cost: cost,
                    supplier: supplier,
                    isDuplicate: false,
                    duplicateOf: null,
                    matchScore: 0,
                    action: 'add',
                    willCreateVariant: false // Flag if this should be a variant
                };
                
                // Check if main ingredient exists (will create variant if supplier or price exists)
                if (ingredientName && (supplier || cost > 0)) {
                    const existingIngredients = JSON.parse(localStorage.getItem('ingredients_database') || '[]');
                    const existingMain = existingIngredients.find(ing => 
                        ing.name.toLowerCase() === ingredientName.toLowerCase() && 
                        !ing.isVariant && 
                        !ing.parentIngredientId
                    );
                    
                    if (existingMain) {
                        ingredient.willCreateVariant = true;
                        ingredient.parentIngredientId = existingMain.id;
                        ingredient.baseName = existingMain.name;
                    }
                }

                // Skip if no name
                if (!ingredient.name) return;

                // Check for duplicates
                const duplicate = findDuplicate(ingredient.name);
                if (duplicate) {
                    ingredient.isDuplicate = true;
                    ingredient.duplicateOf = duplicate;
                    ingredient.matchScore = duplicate.score;
                    ingredient.action = duplicate.score > 90 ? 'skip' : 'review';
                }

                data.push(ingredient);
            });

            uploadedIngredients = data;
            console.log('‚úÖ Parsed ' + data.length + ' ingredients with column mapping');
            
            // Clean up temp data
            window.tempCSVData = null;
            window.tempCSVAllRows = null;
            window.columnMappings = null;
            
            showReview();
        }

        // Helper: Parse CSV line
        function parseCSVLine(line, delimiter) {
            const cells = [];
            let currentCell = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        currentCell += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === delimiter && !inQuotes) {
                    cells.push(currentCell.trim());
                    currentCell = '';
                } else {
                    currentCell += char;
                }
            }
            cells.push(currentCell.trim());
            return cells;
        }

        // Helper: Detect delimiter
        function detectDelimiter(text) {
            const commaCount = (text.match(/,/g) || []).length;
            const semicolonCount = (text.match(/;/g) || []).length;
            const tabCount = (text.match(/\t/g) || []).length;
            if (tabCount > commaCount && tabCount > semicolonCount) return '\t';
            if (semicolonCount > commaCount) return ';';
            return ',';
        }

        // Helper: Find best header match
        function findBestHeaderMatch(fieldKey, headers) {
            const normalizedField = fieldKey.toLowerCase();
            const fieldKeywords = {
                'name': ['name', 'ingredient', 'item', 'product'],
                'category': ['category', 'type', 'class'],
                'unit': ['unit', 'units', 'measurement'],
                'cost': ['cost', 'price', 'amount'],
                'supplier': ['supplier', 'vendor', 'provider']
            };

            const keywords = fieldKeywords[normalizedField] || [normalizedField];
            
            // Try exact match
            for (const keyword of keywords) {
                const match = headers.find(h => h.toLowerCase() === keyword);
                if (match) return match;
            }

            // Try partial match
            for (const keyword of keywords) {
                const match = headers.find(h => h.toLowerCase().includes(keyword) || keyword.includes(h.toLowerCase()));
                if (match) return match;
            }

            return '';
        }

        // Find duplicate ingredients
        function findDuplicate(name) {
            const searchTerm = name.toLowerCase().trim();
            let bestMatch = null;
            let bestScore = 0;

            for (const existing of existingIngredients) {
                const existingName = existing.name.toLowerCase().trim();
                let score = 0;

                // Exact match
                if (existingName === searchTerm) {
                    score = 100;
                }
                // Very close match
                else if (existingName.includes(searchTerm) || searchTerm.includes(existingName)) {
                    score = 90;
                }
                // Word matching
                else {
                    const searchWords = searchTerm.split(/\s+/);
                    const existingWords = existingName.split(/\s+/);
                    let matchedWords = 0;

                    for (const word of searchWords) {
                        if (existingWords.some(ew => ew === word || ew.includes(word) || word.includes(ew))) {
                            matchedWords++;
                        }
                    }

                    score = (matchedWords / Math.max(searchWords.length, existingWords.length)) * 80;
                }

                if (score > bestScore && score >= 75) { // 75% threshold
                    bestScore = score;
                    bestMatch = existing;
                }
            }

            if (bestMatch) {
                return {
                    ingredient: bestMatch,
                    score: Math.round(bestScore)
                };
            }

            return null;
        }

        // Show review screen
        function showReview() {
            document.getElementById('loadingState').classList.remove('active');
            document.getElementById('reviewSection').classList.add('active');

            const newItems = uploadedIngredients.filter(i => !i.isDuplicate).length;
            const duplicates = uploadedIngredients.filter(i => i.isDuplicate).length;
            const willMerge = uploadedIngredients.filter(i => i.action === 'merge').length;

            document.getElementById('newCount').textContent = newItems;
            document.getElementById('duplicateCount').textContent = duplicates;
            document.getElementById('mergeCount').textContent = willMerge;
            document.getElementById('totalCount').textContent = uploadedIngredients.length;

            renderTable();
        }

        // Render table
        function renderTable() {
            const tbody = document.getElementById('ingredientTableBody');
            tbody.innerHTML = '';

            const filtered = uploadedIngredients.filter(item => {
                if (currentFilter === 'new') return !item.isDuplicate;
                if (currentFilter === 'duplicates') return item.isDuplicate;
                return true;
            });

            filtered.forEach((item, index) => {
                const actualIndex = uploadedIngredients.indexOf(item);
                const row = document.createElement('tr');
                
                const statusBadge = item.isDuplicate
                    ? `<span class="status-badge duplicate">‚ö†Ô∏è Duplicate</span>`
                    : `<span class="status-badge new">‚úì New</span>`;

                const matchInfo = item.isDuplicate && item.duplicateOf
                    ? `<div>${item.duplicateOf.ingredient.name}</div>
                       <div class="duplicate-info">
                         <span class="match-score ${item.matchScore > 90 ? 'match-high' : 'match-medium'}">
                           ${item.matchScore}% match
                         </span>
                       </div>`
                    : '<div style="color: #64748b;">No duplicates found</div>';

                const actionOptions = item.isDuplicate
                    ? `<select class="action-select" onchange="updateAction(${actualIndex}, this.value)" value="${item.action}">
                         <option value="skip" ${item.action === 'skip' ? 'selected' : ''}>Skip (Keep Existing)</option>
                         <option value="merge" ${item.action === 'merge' ? 'selected' : ''}>Merge Info</option>
                         <option value="update" ${item.action === 'update' ? 'selected' : ''}>Update Existing</option>
                         <option value="add" ${item.action === 'add' ? 'selected' : ''}>Add as New</option>
                       </select>`
                    : `<select class="action-select" disabled>
                         <option>Add New</option>
                       </select>`;

                row.innerHTML = `
                    <td><strong>${item.name}</strong></td>
                    <td>${item.category}${item.subcategory ? `<br><small style="color: #64748b;">${item.subcategory}</small>` : ''}</td>
                    <td>${item.unit}</td>
                    <td>${item.cost ? '$' + item.cost.toFixed(2) : '-'}</td>
                    <td>${statusBadge}</td>
                    <td>${matchInfo}</td>
                    <td>${actionOptions}</td>
                `;

                tbody.appendChild(row);
            });
        }

        // Update action
        function updateAction(index, action) {
            uploadedIngredients[index].action = action;
            updateStats();
        }

        // Update stats
        function updateStats() {
            const willMerge = uploadedIngredients.filter(i => i.action === 'merge').length;
            document.getElementById('mergeCount').textContent = willMerge;
        }

        // Filter view
        function filterView(filter) {
            currentFilter = filter;
            
            // Update active tab
            document.querySelectorAll('.filter-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            renderTable();
        }

        // Save ingredients
        function saveIngredients() {
            const toAdd = uploadedIngredients.filter(i => i.action === 'add');
            const toMerge = uploadedIngredients.filter(i => i.action === 'merge');
            const toUpdate = uploadedIngredients.filter(i => i.action === 'update');

            let addedCount = 0;
            let mergedCount = 0;
            let updatedCount = 0;

            // Add new ingredients
            toAdd.forEach(item => {
                let newIngredient;
                
                if (item.willCreateVariant) {
                    // Create as variant
                    newIngredient = {
                        id: 'ing_variant_' + Date.now() + '_' + Math.random(),
                        parentIngredientId: item.parentIngredientId,
                        isVariant: true,
                        name: `${item.name} - ${item.supplier || 'Unknown Vendor'}`,
                        baseName: item.baseName || item.name,
                        category: item.category,
                        subcategory: item.subcategory || null,
                        unit: item.unit,
                        cost: item.cost || 0,
                        supplier: item.supplier,
                        dateAdded: new Date().toISOString(),
                        priceHistory: item.cost > 0 ? [{
                            price: item.cost,
                            date: new Date().toISOString(),
                            vendor: item.supplier || 'Default'
                        }] : []
                    };
                } else {
                    // Create as main ingredient
                    newIngredient = {
                        id: 'ing_' + Date.now() + '_' + Math.random(),
                        name: item.name,
                        category: item.category,
                        subcategory: item.subcategory || null,
                        unit: item.unit,
                        cost: item.cost || 0,
                        supplier: item.supplier,
                        dateAdded: new Date().toISOString(),
                        variants: [],
                        priceHistory: item.cost > 0 ? [{
                            price: item.cost,
                            date: new Date().toISOString(),
                            vendor: item.supplier || 'Default'
                        }] : []
                    };
                }
                existingIngredients.push(newIngredient);
                addedCount++;
            });

            // Merge ingredients
            toMerge.forEach(item => {
                if (item.duplicateOf) {
                    const existing = existingIngredients.find(e => e.id === item.duplicateOf.ingredient.id);
                    if (existing) {
                        // Update with new info if available
                        if (item.cost) existing.cost = item.cost;
                        if (item.supplier) existing.supplier = item.supplier;
                        existing.updatedAt = new Date().toISOString();
                        mergedCount++;
                    }
                }
            });

            // Update ingredients
            toUpdate.forEach(item => {
                if (item.duplicateOf) {
                    const existing = existingIngredients.find(e => e.id === item.duplicateOf.ingredient.id);
                    if (existing) {
                        existing.name = item.name;
                        existing.category = item.category;
                        existing.unit = item.unit;
                        existing.cost = item.cost;
                        existing.supplier = item.supplier;
                        existing.updatedAt = new Date().toISOString();
                        updatedCount++;
                    }
                }
            });

            // Save to localStorage
            localStorage.setItem('ingredients_database', JSON.stringify(existingIngredients));

            // Track analytics
            if (window.analyticsTracker) {
                window.analyticsTracker.trackCustomEvent('bulk_ingredients_imported', {
                    added: addedCount,
                    merged: mergedCount,
                    updated: updatedCount,
                    total: uploadedIngredients.length
                });
            }

            alert(`‚úÖ Import Complete!\n\n${addedCount} new ingredients added\n${mergedCount} merged\n${updatedCount} updated`);
            
            // Redirect to ingredients page
            window.location.href = 'ingredients.html';
        }

        // Cancel import
        function cancelImport() {
            if (confirm('Discard imported ingredients?')) {
                resetUpload();
            }
        }

        // Reset upload
        function resetUpload() {
            uploadedIngredients = [];
            window.tempCSVData = null;
            window.tempCSVAllRows = null;
            window.columnMappings = null;
            const mappingSection = document.getElementById('columnMappingSection');
            if (mappingSection) mappingSection.remove();
            document.getElementById('reviewSection').classList.remove('active');
            document.getElementById('loadingState').classList.remove('active');
            document.querySelector('.upload-section').style.display = 'block';
            document.getElementById('fileInput').value = '';
        }

        // Download template
        function downloadTemplate() {
            const template = `Ingredient Name,Category,Unit,Cost,Supplier
Chicken Breast,Protein,lb,12.99,ACME Foods
Olive Oil Extra Virgin,Oils,gal,24.50,Italian Imports
Roma Tomatoes,Produce,lb,2.99,Local Farm
All Purpose Flour,Dry Goods,lb,0.89,Grain Supply Co
Sea Salt,Seasonings,lb,3.99,Specialty Foods
Garlic Fresh,Produce,lb,4.50,Local Farm
Butter Unsalted,Dairy,lb,5.99,Dairy Farm
Heavy Cream,Dairy,qt,6.50,Dairy Farm
`;

            const blob = new Blob([template], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ingredient-import-template.csv';
            a.click();
            URL.revokeObjectURL(url);

            if (window.analyticsTracker) {
                window.analyticsTracker.trackCustomEvent('template_downloaded', {
                    template_type: 'bulk_ingredients'
                });
            }
        }
    </script>
    
    <!-- Load Auth System at End -->
    <script type="module" defer src="assets/js/firebase-auth.js"></script>
    <script defer src="assets/js/header-user-display.js"></script>
    <script defer src="assets/js/profile-editor.js"></script>
    <script defer src="assets/js/auth_guard.js"></script>
</body>
</html>

